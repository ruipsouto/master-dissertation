Query optimization is the link between declarative languages and the efficient execution of queries expressed in them. However, it is essential to state that no optimizer generates optimal plans \citep{Bailis2015}. First, the cost of a particular plan is obtained by considering statistical information about the relations expressed in the query. There is a trade-off between the accuracy of these statistics and their maintenance costs, as more accurate statistics are significantly harder to maintain. For this reason, all optimizers rely on cardinality estimates that are usually measured based on simplifying assumptions such as uniformity and independence \citep{Leis2015}. Such assumptions are often incorrect in real-world data sets, leading to sub-optimal and sometimes disastrous plans.

Furthermore, exploiting a very large search space may have a higher computational cost than the runtime itself and is considered a NP-hard problem. This is why optimizers employ a set of heuristics to limit the size of their search space. The fact that query optimization still relies on carefully tuned and complex heuristics that have been designed over the years means that they require even more tuning by expert database administrators to improve query performance on each database. Additionally, even if using these heuristics is an effective way of restricting the search space, in some cases, they can fall short, resulting in bad plans \citep{Leis2015}.
